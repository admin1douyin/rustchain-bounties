import json
from datetime import datetime
from typing import List, Dict, Any

class StressTestReporter:
    """Generates Markdown reports from stress test results."""

    def __init__(self, target_url: str, total_miners: int, duration: float, results: List[Dict]):
        self.target_url = target_url
        self.total_miners = total_miners
        self.duration = duration
        self.results = results
        self.timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    def generate_markdown(self) -> str:
        successes = [r for r in self.results if r["success"]]
        failures = [r for r in self.results if not r["success"]]
        success_rate = (len(successes) / self.total_miners) * 100 if self.total_miners > 0 else 0

        # Calculate latencies
        total_times = sorted([r["total_time"] for r in self.results if "total_time" in r])
        p50 = total_times[len(total_times)//2] if total_times else 0
        p95 = total_times[int(len(total_times)*0.95)] if len(total_times) >= 20 else p50
        p99 = total_times[int(len(total_times)*0.99)] if len(total_times) >= 100 else p95

        md = f"""# RustChain RIP-200 Stress Test Report
Generated on: `{self.timestamp}`

## âš ï¸ Disclaimer
**Simulation Limitations**: The hardware fingerprints generated by this tool are simulated. While they follow the RIP-200 structure, they do not contain the raw microscopic evidence (e.g., oscillator jitter entropy, cache timing artifacts) required to pass a live server's deep validation if rigorous signal analysis is enabled.

## ğŸ“Š Executive Summary
| Metric | Value |
|--------|-------|
| **Target Node** | `{self.target_url}` |
| **Total Simulated Miners** | {self.total_miners} |
| **Success Rate** | {success_rate:.1f}% ({len(successes)}/{self.total_miners}) |
| **Total Duration** | {self.duration:.2f}s |
| **Avg Throughput** | {len(successes)/self.duration:.2f} miners/sec |

## ğŸ›¡ï¸ Security Observations
- **Rate Limiting (429)**: The occurrence of `429 Too Many Requests` indicates that the node's rate-limiting defense is **active and effective**. This is a positive indicator of system resilience against simple flood attacks.
- **Malformed Payloads**: If malformed tests were run, the success rate reflects the server's ability to correctly reject invalid data.

## ğŸ‘¥ Duplicate ID Analysis
"""
        dupe_results = [r for r in self.results if r.get("is_duplicate")]
        if dupe_results:
            dupe_success = [r for r in dupe_results if r["success"]]
            md += f"- **Duplicate ID Attempts**: {len(dupe_results)}\n"
            md += f"- **Duplicate ID Rejections**: {len(dupe_results) - len(dupe_success)} (Expected rejection of same ID in same epoch)\n"
        else:
            md += "- No duplicate ID tests performed in this session.\n"

        md += """
## â±ï¸ Latency Distribution (Total Session)
"""
- **P50 (Median):** `{p50:.3f}s`
- **P95:** `{p95:.3f}s`
- **P99:** `{p99:.3f}s`

## ğŸ§© Step Breakdown (Average)
| Step | Avg Latency |
|------|-------------|
"""
        for step in ["challenge", "submit", "enroll"]:
            step_times = [r["steps"][step] for r in self.results if step in r["steps"]]
            avg = sum(step_times)/len(step_times) if step_times else 0
            md += f"| {step.capitalize()} | {avg:.3f}s |\n"

        if failures:
            md += "\n## âŒ Error Analysis\n"
            error_counts = {}
            for r in failures:
                err = r.get("error", "Unknown error")
                error_counts[err] = error_counts.get(err, 0) + 1

            md += "| Error Message | Occurrences |\n|---|---|\n"
            for err, count in sorted(error_counts.items(), key=lambda x: x[1], reverse=True)[:10]:
                md += f"| `{err}` | {count} |\n"

        md += "\n---\n*Report generated by RustChain Stress Test Harness v1.0*"
        return md

    def save_report(self, filename: str = "stress_test_report.md"):
        content = self.generate_markdown()
        with open(filename, "w") as f:
            f.write(content)
        print(f"âœ… Report saved to {filename}")
